#!/usr/bin/python3
# Copyright 2015 Alex Woroschilow (alex.woroschilow@gmail.com)
#
# Licensed under the Apache License, Version 2.0 (the "License");
# you may not use this file except in compliance with the License.
# You may obtain a copy of the License at
#
# http://www.apache.org/licenses/LICENSE-2.0
#
# Unless required by applicable law or agreed to in writing, software
# distributed under the License is distributed on an "AS IS" BASIS,
# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
import os, re, glob
import subprocess
from optparse import OptionParser
from time import sleep

class Task(object):
    def __init__(self, path):
        self._path = path
        pass

    @property
    def priority(self):
        priorities = re.findall(r'\d+', self.name)
        if priorities is not None:
            return priorities.pop()
        return None
    
    @property
    def path(self):
        return self._path

    @property
    def start(self):
        return "%s/start" % self._path

    @property
    def status(self):
        return "%s/status" % self._path


    @property
    def name(self):
        return self.path[self.path.rfind('/') + 1:]
    
    def __eq__(self, other):
        return not self.priority < other.priority and not other.priority < self.priority

    def __ne__(self, other):
        return self.priority < other.priority or other.priority < self.priority

    def __gt__(self, other):
        return other.priority < self.priority

    def __ge__(self, other):
        return not self.priority < other.priority

    def __le__(self, other):
        return not other.priority < self.priority    
    
    def __str__(self):
            return self.name


class Queue(object):
    def __init__(self, path):
        self._path = path
        pass

    @property
    def tasks(self):
        for task in glob.glob(self._path):
            yield Task(task)
        pass


    def queue(self):
        collection = [task for task in self.tasks]
        collection.sort(reverse=False)
        for task in collection:
            print(task)


    def start(self, name=None):
        if name is not None:
            return self._start_by_name(name)

        collection = [task for task in self.tasks]
        collection.sort(reverse=False)
        for task in collection:
            process = TaskRunner(task)

            if not process.done and process.ready:
                if not process.wait:
                    return process.start()
            
    def _start_by_name(self, name=None):
        for task in self.tasks:
            if task.name == name:
                return (TaskRunner(task)).start()
            
class TaskRunner(object):
    def __init__(self, task):
        self._task = task
        pass
    
    def start(self):
        with subprocess.Popen([self._task.status], stdout=subprocess.PIPE) as process:
            stdoutdata, stderrdata = process.communicate()
            print(stdoutdata.decode('utf-8'), stderrdata)
            if stdoutdata.decode('utf-8') == 'ready':
                with subprocess.Popen([self._task.start], stdout=subprocess.PIPE) as process:
                    stdoutdata, stderrdata = process.communicate()
                    print(stdoutdata.decode('utf-8'), stderrdata)

    @property
    def status(self):
        return self._status;
    
    @property
    def done(self):
        return (self.status.find('done') is not -1)
    
    @property
    def ready(self):
        return (self.status.find('ready') is not -1)

    @property
    def wait(self):
        return (self.status.find('wait') is not -1)


if __name__ == "__main__":
    parser = OptionParser()
    parser.add_option("-t", "--task", default=False, dest="task", help="enable debug mode")
    parser.add_option("-q", "--queue", action="store_true", default=False, dest="queue", help="show devices")


    (options, args) = parser.parse_args()

    queue = Queue("%s/salami.d/*" % os.getcwd())
    queue.queue() \
        if options.queue \
        else queue.start(options.task)
